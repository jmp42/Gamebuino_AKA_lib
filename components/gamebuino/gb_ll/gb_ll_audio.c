/*
This file is part of the Gamebuino-AKA library,
Copyright (c) Gamebuino 2026

This is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License (LGPL)
as published by the Free Software Foundation, either version 3 of
the License, or (at your option) any later version.

This is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License (LGPL) for more details.

You should have received a copy of the GNU Lesser General Public
License (LGPL) along with the library.
If not, see <http://www.gnu.org/licenses/>.

Authors:
 - Jean-Marie Papillon
*/

#include "gb_common.h"
#include "gb_ll_i2c.h"
#include "gb_ll_expander.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "soc/soc_caps.h"
#include "esp_log.h"
#include "driver/i2s_std.h"
#include <string.h>  // <cstring> en C++
#include "gb_ll_lcd.h"
#include "gb_ll_audio.h"
#include "TAS2505_regs.h"
#include "gb_ll_system.h"

//#define USE_MCLK_ON_GPIO42    // map MCLK on GPIO 42 @ 11 Mhz : same sound


static i2s_chan_handle_t                tx_chan;        // I2S tx channel handler


int16_t i16_fifo[ GB_AUDIO_BUFFER_SAMPLE_COUNT * GB_AUDIO_BUFFER_FIFO_COUNT];
//uint8_t u8_fifo[1];
uint32_t u32_idx_read = 0;
uint32_t u32_idx_write = 0;
uint32_t inline fifo_size() { return count_of(i16_fifo); }
uint32_t inline fifo_used() { return u32_idx_write - u32_idx_read ; }
uint32_t inline fifo_free() { return fifo_size() - fifo_used(); }

uint32_t gb_ll_audio_fifo_buffer_count() { return count_of(i16_fifo)/GB_AUDIO_BUFFER_SAMPLE_COUNT; }
uint32_t gb_ll_audio_fifo_buffer_used() { return (u32_idx_write - u32_idx_read)/GB_AUDIO_BUFFER_SAMPLE_COUNT ; }
uint32_t gb_ll_audio_fifo_buffer_free() { return gb_ll_audio_fifo_buffer_count() - gb_ll_audio_fifo_buffer_used(); }

//#define BLOCK_WAV_READ 512  // 512 bytes at a time
uint16_t u16_buffer_miss = 0;        // count missing data during playback
uint16_t u16_buffer_overvlw = 0;     // count surnum data during playback



void gb_ll_audio_push_buffer( const int16_t* pi16_audio_buffer )
{
    if ( fifo_free() >= GB_AUDIO_BUFFER_SAMPLE_COUNT )
    {
        memcpy( &i16_fifo[u32_idx_write%fifo_size()], pi16_audio_buffer, 2 * GB_AUDIO_BUFFER_SAMPLE_COUNT);
/*
        int16_t* pi16_psrc = pi16_audio_buffer;
        int16_t* pi16_dest = &i16_fifo[u32_idx_write%fifo_size()];
        for ( uint16_t u16_idx = 0 ; u16_idx < GB_AUDIO_BUFFER_SAMPLE_COUNT; u16_idx++ )
        {
//            *pi16_dest++ = *pi16_psrc++;
            int16_t i16_data = *pi16_psrc++;
            *pi16_dest++ = i16_data;
        }
*/
        u32_idx_write += GB_AUDIO_BUFFER_SAMPLE_COUNT;
    }
    else
        u16_buffer_overvlw++;

}


IRAM_ATTR bool i2s_cb(i2s_chan_handle_t handle, i2s_event_data_t *event, void *user_ctx)
{
    int16_t* pSamples = event->dma_buf;
    uint16_t pWordLength = event->size/2;

    if ( fifo_used() >= pWordLength )
    {
        memcpy( pSamples, &i16_fifo[u32_idx_read%fifo_size()], 2 * GB_AUDIO_BUFFER_SAMPLE_COUNT);
        u32_idx_read += pWordLength;//event->size;
    }
    else
    {
        u16_buffer_miss++;
        while ( pWordLength-- )
            *pSamples++ = 0;
    }

    return true;
}

i2s_event_callbacks_t i2s_event_callbacks = {
    .on_recv = 0,
    .on_recv_q_ovf = 0,
    .on_sent = i2s_cb,
    .on_send_q_ovf = 0
};

int gb_ll_init_i2S()
{
    /* Setp 1: Determine the I2S channel configuration and allocate two channels one by one
        * The default configuration can be generated by the helper macro,
        * it only requires the I2S controller id and I2S role
        * The tx and rx channels here are registered on different I2S controller,
        * Except ESP32 and ESP32-S2, others allow to register two separate tx & rx channels on a same controller */
//    i2s_chan_config_t tx_chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
    i2s_chan_config_t tx_chan_cfg = {
        .id = I2S_NUM_AUTO,
        .role = I2S_ROLE_MASTER,
        .dma_desc_num = 2,
        .dma_frame_num = GB_AUDIO_BUFFER_SAMPLE_COUNT, // 256 x 16b samples
        .auto_clear_after_cb = false,
        .auto_clear_before_cb = false,
        .allow_pd = false,
        .intr_priority = 3,
    };

    ESP_ERROR_CHECK(i2s_new_channel(&tx_chan_cfg, &tx_chan, NULL));

    /* Step 2: Setting the configurations of standard mode and initialize each channels one by one
        * The slot configuration and clock configuration can be generated by the macros
        * These two helper macros is defined in 'i2s_std.h' which can only be used in STD mode.
        * They can help to specify the slot and clock configurations for initialization or re-configuring */
    i2s_std_config_t tx_std_cfg = {
        .clk_cfg  = I2S_STD_CLK_DEFAULT_CONFIG(GB_AUDIO_SAMPLE_RATE),

        .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_MONO),
        .gpio_cfg = {
#ifdef USE_MCLK_ON_GPIO42
            .mclk = GPIO_NUM_42, //I2S_GPIO_UNUSED,    // some codecs may require mclk signal, this example doesn't need it
#else            
            .mclk = I2S_GPIO_UNUSED,    // some codecs may require mclk signal, this example doesn't need it
#endif
            .bclk = I2S_PIN_BCLK,
            .ws   = I2S_PIN_WS,
            .dout = I2S_PIN_DOUT,
            .din  = I2S_GPIO_UNUSED,
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                .ws_inv   = false,
            },
        },
    };
    tx_std_cfg.slot_cfg.bit_shift = true;
    ESP_ERROR_CHECK(i2s_channel_init_std_mode(tx_chan, &tx_std_cfg));

    //    ESP_ERROR_CHECK(i2s_channel_preload_data(tx_chan, cos44100, 256, &w_bytes));
    i2s_channel_register_event_callback( tx_chan, &i2s_event_callbacks, (void*)0 );
    ESP_ERROR_CHECK(i2s_channel_enable(tx_chan));


    return 0;
}

//uint8_t u8_volume = 0; // max
int gb_ll_audio_init()
{
    printf( "audio_init()\n" );
    gb_ll_expander_audio_amplifier_reset(0);
    gb_delay_ms(100);
    gb_ll_expander_audio_amplifier_reset(1);
    gb_delay_ms(100);
    gb_ll_init_i2S();

        // Page switch to Page 0
    gb_ll_audio_amp_write( AUDIO_AMP_REG_PAGE, 0 ); // W 30 00 00
        //Assert Software reset (P0, R1, D0=1)  
    gb_ll_audio_amp_write( AUDIO_AMP_SOFT_RESET, 1 );    // W 30 01 01

        // Page Switch to Page 1
    gb_ll_audio_amp_write( AUDIO_AMP_REG_PAGE, 1 );   // W 30 00 01
        // LDO output programmed as 1.8V and Level shifters powered up. (P1, R2, D5-D4=00, D3=0)
    gb_ll_audio_amp_write( AUDIO_AMP_P1_LDO_CTRL, 0 );// W 30 02 00
        // Page switch to Page 0
    gb_ll_audio_amp_write( AUDIO_AMP_REG_PAGE, 0 ); // W 30 00 00
    // PLL_clkin = BCLK, codec_clkin = PLL_CLK, MCLK should be 11.2896MHz (P0, R4, D1-D0=03)
#ifdef USE_MCLK_ON_GPIO42
    gb_ll_audio_amp_write( AUDIO_AMP_P0_CLK_SETTING1, 3 ); // w 30 04 03
#else
    gb_ll_audio_amp_write( AUDIO_AMP_P0_CLK_SETTING1, 4+3 ); // w 30 04 03
#endif

        // Power up PLL, set P=1, R=3, (Page-0, Reg-5)
#ifdef USE_MCLK_ON_GPIO42
    gb_ll_audio_amp_write( AUDIO_AMP_P0_CLK_SETTING2, 0x91 ); // w 30 05 91
#else
    gb_ll_audio_amp_write( AUDIO_AMP_P0_CLK_SETTING2, 0x93 ); // w 30 05 91
#endif

        // Set J=20, (Page-0, Reg-6)
    gb_ll_audio_amp_write( 6, 20 ); // w 30 06 04
        // D = 0000, D(13:8) = 0, (Page-0, Reg-7)
    gb_ll_audio_amp_write( 7, 0x00 ); // w 30 07 00
        // D(7:0) = 0, (Page-0, Reg-8)
    gb_ll_audio_amp_write( 8, 0x00 ); // w 30 08 00
        // add delay of 15 ms for PLL to lock
    gb_delay_ms(15); 
        // DAC NDAC Powered up, NDAC=4 (P0, R11, D7=1, D6-D0=0000100)
    gb_ll_audio_amp_write( 0x0B, 0x84 ); // W 30 0B 84
        // DAC MDAC Powered up, MDAC=2 (P0, R12, D7=1, D6-D0=0000010)
    gb_ll_audio_amp_write( 0x0C, 0x82 ); // W 30 0C 82
        // DAC OSR(9:0)-> DOSR=128 (P0, R12, D1-D0=00)
    gb_ll_audio_amp_write( 0x0D, 0x00 ); // W 30 0D 00
        // DAC OSR(9:0)-> DOSR=128 (P0, R13, D7-D0=10000000)
    gb_ll_audio_amp_write( 0x0E, 0x80 ); // W 30 0E 80
        // Codec Interface control Word length = 16bits, BCLK&WCLK inputs, I2S mode. (P0, R27, D7-D6=00, D5-D4=00, D3-D2=00)
    gb_ll_audio_amp_write( AUDIO_AMP_AIS_REG1, 0x00 ); // W 30 1B 00
        // Data slot offset 00 (P0, R28, D7-D0=0000)
    gb_ll_audio_amp_write( 0x1C, 0x00 ); // W 30 1C 00
        // Dac Instruction programming PRB #2 for Mono routing. Type interpolation (x8) and 3 programmable Biquads. (P0, R60, D4-D0=0010)
    gb_ll_audio_amp_write( 0x3C, 0x02 ); // W 30 3C 02

        // Page switch to Page 0
    gb_ll_audio_amp_write( AUDIO_AMP_REG_PAGE, 0 ); // W 30 00 00
        // DAC powered up, Soft step 1 per Fs. (P0, R63, D7=1, D5-D4=01, D3-D2=00, D1-D0=00)
    gb_ll_audio_amp_write( 0x3F, 0x90 ); // W 30 3F 90
        // DAC digital gain 0dB (P0, R65, D7-D0=00000000)
    gb_ll_audio_amp_write( 0x41, 0x00 ); // W 30 41 00
        // DAC volume not muted. (P0, R64, D3=0, D2=1)
    gb_ll_audio_amp_write( 0x40, 0x04 ); // W 30 40 04

        // Page Switch to Page 1
    gb_ll_audio_amp_write( AUDIO_AMP_REG_PAGE, 0x01 ); // W 30 00 01
        // Master Reference Powered on (P1, R1, D4=1)
    gb_ll_audio_amp_write( 0x01, 0x10 ); // W 30 01 10
        // Output common mode for DAC set to 0.9V (default) (P1, R10)
    gb_ll_audio_amp_write( 0x0A, 0x00 ); // W 30 0A 00
        // Mixer P output is connected to HP Out Mixer (P1, R12, D2=1)
    gb_ll_audio_amp_write( 0x0C, 0x04 ); // w 30 0C 04
        // HP Volume, 0dB Gain (P1, R22, D6-D0=0000000)
    gb_ll_audio_amp_write( 0x16, 0x00 ); // W 30 16 00
        // No need to enable Mixer M and Mixer P, AINL Voulme, 0dB Gain (P1, R24, D7=1, D6-D0=0000000)
    gb_ll_audio_amp_write( 0x18, 0x00 ); // W 30 18 00
    gb_ll_audio_amp_write( 0x19, 0x00 ); // W 30 18 00
        // Power up HP (P1, R9, D5=1)
    gb_ll_audio_amp_write( 0x09, 0x20 ); // w 30 09 20
        // Unmute HP with 0dB gain (P1, R16, D4=1)
    gb_ll_audio_amp_write( 0x10, 0x00 ); // w 30 10 00
        // SPK attn. Gain =0dB (P1, R46, D6-D0=000000)
    gb_ll_audio_amp_write( AUDIO_AMP_P1_SPK_VOL, 0 ); // 32 dB att : set to max
        // SPK driver Gain=6.0dB (P1, R48, D6-D4=001)
    gb_ll_audio_amp_write( AUDIO_AMP_P1_SPK_AMP_VOL, 0x20 ); // + 12 dB, ok sur 1W
        // SPK powered up (P1, R45, D1=1)
    gb_ll_audio_amp_write( AUDIO_AMP_REG_PAGE, 0x01 ); // W 30 00 01        
    gb_ll_audio_amp_write( AUDIO_AMP_P1_SPK_AMP, 0x02 ); // W 30 2D 02

    return 0;
}


void gb_ll_audio_set_volume( uint8_t u8_volume )
{
    u8_volume = 127 - u8_volume/2; // 0  volume max, 116 = volume min
    gb_ll_audio_amp_write( AUDIO_AMP_REG_PAGE, 1 ); // switch page 1
    if( u8_volume >= 116 ) // mute
    {
        gb_ll_audio_amp_write( AUDIO_AMP_P1_SPK_VOL, 0x7F ); 
        gb_ll_audio_amp_write( AUDIO_AMP_P1_HP_SPK_VOL, 0x7F ); 
    }
    else
    {
        gb_ll_audio_amp_write( AUDIO_AMP_P1_SPK_VOL, u8_volume ); 
        gb_ll_audio_amp_write( AUDIO_AMP_P1_HP_SPK_VOL, u8_volume ); 
    }
}

void gb_ll_audio_set_vibrator( uint8_t u8_on )
{
    gb_ll_audio_amp_write( AUDIO_AMP_REG_PAGE, 0 ); // W 30 00 00

    if ( u8_on ) // toggle on
        gb_ll_audio_amp_write( AUDIO_AMP_P0_GPIO_CTRL, 0b00001101 ); // Set as HIGH
    else
        gb_ll_audio_amp_write( AUDIO_AMP_P0_GPIO_CTRL, 0b00001100 ); // Set as LOW
}